from email.mime import image
from enum import Enum
import io
from typing import Optional
from fastapi import (
    APIRouter,
    Body,
    Request,
    Response,
    HTTPException,
    Depends,
    Query,
    status,
)
from fastapi.responses import FileResponse, StreamingResponse
from models.predictor import (
    MongoBaseModel,
    MetadataOutput,
    Predictor,
    PredictionInput,
    PredictionOutput,
    Image,
    ImagesList,
    Text,
    FeatureImportanceOutput,
    get_model,
)
from models.match import Match
from config import settings

responses: dict[int, dict[str, str]] = {
    404: {"description": "Item not found"},
    302: {"description": "The item was moved"},
    403: {"description": "Not enough privileges"},
}


class Platform(str, Enum):
    euw1 = ("euw1",)
    br1 = ("br1",)
    eun1 = ("eun1",)
    jp1 = ("jp1",)
    kr = ("kr",)
    la1 = ("la1",)
    la2 = ("la2",)
    na1 = ("na1",)
    oc1 = ("oc1",)
    tr1 = ("tr1",)
    ru = "ru"


class League(str, Enum):
    challengers = ("challengers",)
    grandmasters = ("grandmasters",)
    masters = ("masters",)
    diamonds = "diamonds"


model_router: APIRouter = APIRouter()


@model_router.on_event("startup")
async def startup() -> None:
    """Initialize the tftchamp pipeline"""
    await get_model().load_model()


@model_router.get("/feature_importance", response_model=FeatureImportanceOutput)
async def models(
    model: Predictor = Depends(get_model),
    platform: Platform = "na1",
    league: League = "challengers",
    version: str = settings.latest_release,
    patch: str = settings.patch.strftime("%Y-%m-%d"),
) -> FeatureImportanceOutput:
    response: FeatureImportanceOutput = {
        "results": await model.get_feature_importance(
            platform=platform, league=league, version=version, patch=patch
        )
    }
    return response


@model_router.post("/prediction", response_model=PredictionOutput)
async def prediction(
    request: Match, model: Predictor = Depends(get_model)
) -> PredictionOutput:
    output: PredictionOutput = model.predict(request)
    return output


@model_router.get(
    "/metadata",
    response_description="get latest metadata",
    response_model=MetadataOutput,
)
async def get_metadata() -> MetadataOutput:
    responses: MetadataOutput = {
        "latest_version": settings.latest_release,
        "latest_patch": settings.patch.strftime("%Y-%m-%d"),
    }
    return responses


@model_router.get(
    "/image/{id}",
    response_description="Get a single match by id",
    # Set what the media type will be in the autogenerated OpenAPI specification.
    # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
    responses={
        **responses,
        200: {
            "content": {"image/png": {}},
            "description": "Return the JSON item or an image.",
        },
    },
    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=Response,
)
async def find_image(
    id: str,
    request: Request,
    platform: Platform = "na1",
    league: League = "challengers",
    version: str = settings.latest_release,
    patch: str = settings.patch.strftime("%Y-%m-%d"),
) -> Response:
    # print(request.app.config)pickle.loads(
    if (
        binary := await request.app.database[
            f"{platform}_{league}_{version}_{patch}_binary"
        ].find_one({"_id": id})
    ) is not None:
        im = binary["image"]
        return Response(content=im, media_type="image/png")

    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail=f"Image with ID {id} {platform}_{league}_{version}_{patch} not found",
    )


@model_router.get(
    "/image", response_description="List all images", response_model=ImagesList
)
async def list_images(
    request: Request,
    platform: Platform = "na1",
    league: League = "challengers",
    version: str = settings.latest_release,
    patch: str = settings.patch.strftime("%Y-%m-%d"),
) -> ImagesList:
    query = request.app.database[f"{platform}_{league}_{version}_{patch}_binary"].find(
        {}, {"_id": 1, "image": 0}
    )
    results: list[Text] = [Text(**raw_post) async for raw_post in query]
    image_list = []
    for image in results:
        result = {"uri": image.id, "description": image.text}
        image_list.append(result)
    response: ImagesList = {"results": image_list}
    return response
